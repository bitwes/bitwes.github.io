<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link id="maincss" rel="stylesheet" href="github-markdown.css">
    <link rel="stylesheet" href="exported_wiki.css">
</head>


<body>

<!------------------------------------------------------------------------->
<!-- THE TOC STARTS HERE                                                 -->
<!------------------------------------------------------------------------->

    <div id="toc" class="w3-sidebar w3-border-right">
        <div class="markdown-body">
            <embed>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Gut Wiki</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="github-markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Gut Wiki</h1>
</header>
<h3 id="741-godot-3x">7.4.1 (Godot 3.x)</h3>
<h3 id="all-pages">All Pages</h3>
<ul>
<li><a href="Asserts-and-Methods.html">Asserts-and-Methods</a></li>
<li><a href="Command-Line.html">Command-Line</a></li>
<li><a href="Comparing-Things.html">Comparing-Things</a></li>
<li><a href="Contributing.html">Contributing</a></li>
<li><a href="Creating-Tests.html">Creating-Tests</a></li>
<li><a href="Doubles.html">Doubles</a></li>
<li><a href="Export-Test-Results.html">Export-Test-Results</a></li>
<li><a
href="Gut-Settings-And-Methods.html">Gut-Settings-And-Methods</a></li>
<li><a href="Home.html">Home</a></li>
<li><a href="Hooks.html">Hooks</a></li>
<li><a href="Inner-Test-Classes.html">Inner-Test-Classes</a></li>
<li><a href="Input-Factory.html">Input-Factory</a></li>
<li><a href="Install.html">Install</a></li>
<li><a href="Memory-Management.html">Memory-Management</a></li>
<li><a href="Mock-Input.html">Mock-Input</a></li>
<li><a href="Orphans.html">Orphans</a></li>
<li><a href="Parameterized-Tests.html">Parameterized-Tests</a></li>
<li><a href="Partial-Doubles.html">Partial-Doubles</a></li>
<li><a href="Quick-Start.html">Quick-Start</a></li>
<li><a href="Running-On-Devices.html">Running-On-Devices</a></li>
<li><a href="Simulate.html">Simulate</a></li>
<li><a href="Spies.html">Spies</a></li>
<li><a href="Stubbing.html">Stubbing</a></li>
<li><a href="Tutorials.html">Tutorials</a></li>
<li><a href="Yielding.html">Yielding</a></li>
</ul>
</body>
</html>

            </embed>
        </div>
    </div>


<!------------------------------------------------------------------------->
<!-- THE PAGE STARTS HERE                                                -->
<!------------------------------------------------------------------------->
    <div class="wiki-div">
        <div class="markdown-body">
            <embed>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Yielding</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="github-markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Yielding</h1>
</header>
<h2 id="-yielding-during-a-test"><a name="yielding"> Yielding during a
test</h2>
<p>I'm not going to try and explain yielding here. It can be a bit
confusing and <a
href="https://docs.godotengine.org/en/latest/getting_started/scripting/gdscript/gdscript_basics.html#coroutines-with-yield">Godot
does a pretty good job of it already</a>. Gut has support for yielding
though, so you can yield at anytime in your test.</p>
<p>When might you want to yield? Yielding is very handy when you want to
wait for a signal to occur instead of running for a finite amount of
time. For example, you could have your test yield until your character
gets hit by something (<code>yield(my_char, 'hit')</code>). An added
bonus of this approach is that you can watch everything happen. In your
test you create your character, the object to hit it, and then watch the
interaction play out.</p>
<p>Here's an example of yielding to a custom signal.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode gdscript"><code class="sourceCode gdscript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_yield_to_custom_signal</span>():</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    my_object <span class="op">=</span> ObjectToTest.<span class="fu">new</span>()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">add_child_autofree</span>(my_object)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(my_object, <span class="st">&#39;custom_signal&#39;</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(some_condition, <span class="st">&#39;After signal fired, this should be true&#39;</span>)</span></code></pre></div>
<h3 id="yield_to">yield_to</h3>
<p>Sometimes you need to wait for a signal to be emitted, but you can
never really be sure it will, we are making tests after all. You could
<code>yield</code> to that signal in your test and hope it gets emitted.
If it doesn't though, your test will just hang forever. The
<code>yield_to</code> method addresses this by allowing you to
<code>yield</code> to a signal or a maximum amount of time, whichever
occurs first. You must make sure the 2nd parameter to <code>yield</code>
is the <code>YIELD</code> constant. This constant is available to all
test scripts. As an extra bonus, Gut will watch the signals on the
object you passed in, so you can save yourself a call to
<code>watch_signals</code> if you want, but you don't have to. How all
this magic works is covered a couple of sections down.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode gdscript"><code class="sourceCode gdscript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># wait for my_object to emit the signal &#39;my_signal&#39;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># or 5 seconds, whichever comes first.</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="cf">yield</span>(<span class="fu">yield_to</span>(my_object, <span class="st">&#39;my_signal&#39;</span>, <span class="dv">5</span>), YIELD)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">assert_signal_emitted</span>(my_object, <span class="st">&#39;my_signal&#39;</span>, \</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>                     <span class="st">&#39;Maybe it did, maybe it didnt, but we still got here.&#39;</span>)</span></code></pre></div>
<h3 id="yield_for">yield_for</h3>
<p>Another use case I have come across is when creating integration
tests and you want to verify that a complex interaction ends with an
expected result. In this case you might have an idea of how long the
interaction will take to play out but you don't have a signal that you
can attach to. Instead you want to pause your test execution until that
time has elapsed. For this, Gut has the <code>yield_for</code> method.
For example <code>yield(yield_for(5), YIELD)</code> will pause your test
execution for 5 seconds while the rest of your code executes as
expected. You must make sure the 2nd parameter to <code>yield</code> is
the <code>YIELD</code> constant. This constant is available to all test
scripts. How all this magic works is covered a couple of sections
down.</p>
<p>Here's an example of yielding for 5 seconds.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode gdscript"><code class="sourceCode gdscript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_wait_for_a_bit</span>():</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    my_object <span class="op">=</span> ObjectToTest.<span class="fu">new</span>()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    my_object.<span class="fu">do_something</span>()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">#wait 5 seconds</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(<span class="fu">yield_for</span>(<span class="dv">5</span>), YIELD)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    gut.<span class="fu">assert_eq</span>(my_object.some_property, <span class="st">&#39;some value&#39;</span>, <span class="st">&#39;After waiting 5 seconds, this property should be set&#39;</span>)</span></code></pre></div>
<h3 id="pause_before_teardown">pause_before_teardown</h3>
<p>Sometimes it's also helpful to just watch things play out. Yield is
great for that, you just create a couple objects, set them to interact
and then yield. You can leave the yields in or take them out if your
test passes without them. You can also use the
<code>pause_before_teardown</code> method that will pause test execution
before it runs <code>teardown</code> and moves onto the next test. This
keeps the game loop running after the test has finished and you can see
what everything looks like.</p>
<h3 id="how-yielding-and-gut-works">How Yielding and Gut Works</h3>
<p>For those that are interested, Gut is able to detect when a test has
called yield because the method returns a special class back
(<code>GDScriptFunctionState</code>). Gut itself will then
<code>yield</code> to the <code>completed</code> signal provided by the
<code>GDScriptFunctionState</code> that is returned when your test
yielded. It also kicks off a timer that will print out messages so you
know it hasn't locked up.</p>
<p>The <code>yield_for()</code> method and <code>YIELD</code> constant
are some syntax sugar built into the <code>Test</code> object.
<code>yield</code> takes in an object and a signal. The
<code>yield_for</code> method kicks off a timer inside Gut that will run
for however many seconds you passed in. It also returns the Gut object
so that <code>yield</code> has an object to yield to. The
<code>YIELD</code> constant contains the name of the signal that Gut
emits when the timer finishes.</p>
<p><code>yield_to</code> works similarly to <code>yield_for</code>
except it takes the extra step that Gut will watch the signal you pass
in. It will emit the same signal (<code>YIELD</code>) when it detects
the signal you specified or it will emit the signal when the timer times
out.</p>
</body>
</html>

            </embed>
        </div>
    </div>

</body>

</html>