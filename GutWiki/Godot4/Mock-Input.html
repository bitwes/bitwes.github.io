<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link id="maincss" rel="stylesheet" href="github-markdown.css">
    <link rel="stylesheet" href="exported_wiki.css">
</head>


<body>

<!------------------------------------------------------------------------->
<!-- THE TOC STARTS HERE                                                 -->
<!------------------------------------------------------------------------->

    <div id="toc" class="w3-sidebar w3-border-right">
        <div class="markdown-body">
            <embed>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Gut Wiki</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="github-markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Gut Wiki</h1>
</header>
<h3 id="900-godot-4x">9.0.0 (Godot 4.x)</h3>
<ul>
<li><a href="Asserts-and-Methods.html">Asserts-and-Methods</a></li>
<li><a href="Command-Line.html">Command-Line</a></li>
<li><a href="Comparing-Things.html">Comparing-Things</a></li>
<li><a href="Contributing.html">Contributing</a></li>
<li><a href="Creating-Tests.html">Creating-Tests</a></li>
<li><a href="Doubles.html">Doubles</a></li>
<li><a href="Export-Test-Results.html">Export-Test-Results</a></li>
<li><a
href="Gut-Settings-And-Methods.html">Gut-Settings-And-Methods</a></li>
<li><a href="Home.html">Home</a></li>
<li><a href="Hooks.html">Hooks</a></li>
<li><a href="Inner-Test-Classes.html">Inner-Test-Classes</a></li>
<li><a href="Input-Factory.html">Input-Factory</a></li>
<li><a href="Install.html">Install</a></li>
<li><a href="Memory-Management.html">Memory-Management</a></li>
<li><a href="Mock-Input.html">Mock-Input</a></li>
<li><a href="Orphans.html">Orphans</a></li>
<li><a href="Parameterized-Tests.html">Parameterized-Tests</a></li>
<li><a href="Partial-Doubles.html">Partial-Doubles</a></li>
<li><a href="Quick-Start.html">Quick-Start</a></li>
<li><a href="Running-On-Devices.html">Running-On-Devices</a></li>
<li><a href="Simulate.html">Simulate</a></li>
<li><a href="Spies.html">Spies</a></li>
<li><a href="Stubbing.html">Stubbing</a></li>
<li><a href="Tutorials.html">Tutorials</a></li>
<li><a href="Yielding.html">Yielding</a></li>
</ul>
</body>
</html>

            </embed>
        </div>
    </div>


<!------------------------------------------------------------------------->
<!-- THE PAGE STARTS HERE                                                -->
<!------------------------------------------------------------------------->
    <div class="wiki-div">
        <div class="markdown-body">
            <embed>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Mock-Input</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="github-markdown.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Mock-Input</h1>
</header>
<h1 id="input-sender">Input Sender</h1>
<p>The <code>InputSender</code> class can be used to send
<code>InputEvent*</code> events to various objects. It also allows you
to script out a series of inputs and play them back in real time. You
could use it to:</p>
<ul>
<li>Verify that jump height depends on how long the jump button is
pressed.</li>
<li>Double tap a direction performs a dash.</li>
<li>Down, Down-Forward, Forward + punch throws a fireball.</li>
</ul>
<p>And much much more.</p>
<h1 id="methods">Methods</h1>
<p>| <a href="#add_receiver">add_receiver</a>| <a
href="#get_receivers">get_receivers</a>| <a
href="#release_all">release_all</a>| <a href="#clear">clear</a>| <a
href="#is_idle">is_idle</a>| <a href="#wait">wait</a>| <a
href="#wait_frames">wait_frames</a>| <a href="#wait_secs">wait_secs</a>|
<a href="#hold_for">hold_for</a>| <a
href="#mouse_set_position">mouse_set_position</a>| <a
href="#set_auto_flush_input">set_auto_flush_input</a>| <a
href="#get_auto_flush_input">get_auto_flush_input</a>|</p>
<h1 id="sending-inputevents">Sending InputEvents</h1>
<p>| <a href="#send_event">send_event</a>| <a
href="#action_down">action_down</a>| <a href="#action_up">action_up</a>|
<a href="#key_down">key_down</a>| <a href="#key_echo">key_echo</a>| <a
href="#key_up">key_up</a>| <a
href="#mouse_double_click">mouse_double_click</a>| <a
href="#mouse_left_button_down">mouse_left_button_down</a>| <a
href="#mouse_left_button_up">mouse_left_button_up</a>| <a
href="#mouse_motion">mouse_motion</a>| <a
href="#mouse_relative_motion">mouse_relative_motion</a>| <a
href="#mouse_right_button_down">mouse_right_button_down</a>| <a
href="#mouse_right_button_up">mouse_right_button_up</a>|</p>
<h1 id="signals">Signals</h1>
<ul>
<li><code>idle</code> - Emitted when all events in the input queue have
been sent.</li>
</ul>
<h1 id="usage">Usage</h1>
<p>The <code>InputSender</code> class operates on one or more receivers.
It will create and send <code>InputEvent</code> instances to all of its
receivers.</p>
<p>There are two ways you could be processing your input. You could be
using the <code>_input</code> events to receive input events and process
them. The other way is to interact with the <code>Input</code> global
and detect input in the <code>_process</code> and
<code>_physics_process</code> methods. <code>InputSender</code> works
with both approaches, but using <code>InputSender</code> differs for
each approach. Read the sections below to learn the best way to use
<code>InputSender</code> with your game.</p>
<h2 id="using-an-object-as-a-receiver">Using an Object as a
Receiver</h2>
<p>When you use an instance of an object as a receiver,
<code>InputSender</code> will send <code>InputEvent</code> instances to
the various <code>input</code> methods. They will be called in this
order:</p>
<ol type="1">
<li><code>_input</code></li>
<li><code>_gui_input</code></li>
<li><code>_unhandled_input</code></li>
</ol>
<p>When there are multipe receivers, each receiver will be called in the
order they were added. All three <code>_input</code> methods will be
called on each reciever then the <code>InputSender</code> will move to
the next receiver.</p>
<p>When using objects as recievers it is recommended that each test
create its own instance of <code>InputSender</code>.
<code>InputSender</code> retains information about what
actions/buttons/etc have been pressed. By creating a new instance in
each test, you don't have to worry about clearing this state between
tests.</p>
<p>If you are processing input by directly interacting with the
<code>Input</code> global, then you should follow the instructions in
the next section.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode gdscript"><code class="sourceCode gdscript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_shoot</span>():</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> player <span class="op">=</span> Player.<span class="fu">new</span>()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> sender <span class="op">=</span> InputSender.<span class="fu">new</span>(player)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    sender.<span class="fu">action_down</span>(<span class="st">&quot;shoot&quot;</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(player.<span class="fu">is_shooting</span>())</span></code></pre></div>
<h2 id="using-input-as-a-receiver">Using <code>Input</code> as a
Receiver</h2>
<p>!!! <b><code>Input.use_accumualted_input</code> DISCLAIMER
<b/>!!!</p>
<p>In Godot 3.4 <code>Input.use_accumualted_input</code> is disabled by
default (even though the documentation indicates otherwise). In Godot
3.5 it is enabled by default. This changes the way that
<code>Input</code> buffers events that are sent to it. See the section
below about <code>use_accumulated_input</code> before continuing.</p>
<hr>

<p>When <code>Input</code> is used as a reciever <code>Input</code> will
send all inputs it receives from the <code>InputSender</code> to every
object that has been added to the tree. <code>Input</code> will treat
all the events it gets exactly the same as if the events were triggered
from hardware. This means all the <code>is_action_just_pressed</code>
and similar functions will work the same. The <code>InputEvent</code>
instances will also be sent to the various <code>_input</code> methods
on objects in the tree in whatever order <code>Input</code> desires.</p>
<p>Using <code>Input</code> makes testing objects that handle input via
<code>_process</code> or <code>_process_delta</code> much easier but you
have to be a little careful when using it though. Since the
<code>Input</code> instance is global and retains its state for the
duration of the test run.</p>
<ol type="1">
<li>You should declare your <code>InputSender</code> instance at the
class level. You will need access to it in the <code>after_each</code>
method.</li>
<li>Call <code>release_all</code> on the <code>InputSender</code> in
<code>after_each</code>. This makes sure that <code>Input</code> doesn't
think that a button is pressed when you don't expect it to be. If
<code>Input</code> thinks a button is pressed, it will not send any
"down" events until it gets an "up" event.</li>
<li>Call <code>clear</code> on the <code>InputSender</code> in
<code>after_each</code>. This clears out any state the
<code>InputSender</code> has. It tracks inputs so that functions like
<code>hold_for</code> can create dyanmic "up" events, as well as various
other things. Calling <code>clear</code> makes sure that
<code>InputSender</code> state does not leak from one test to
another.</li>
<li>You must ALWAYS yield before making an assert or your objects will
not get a chance to process the frame the <code>Input</code> was sent on
(<code>_process</code> and <code>_physics_process</code> will not be
called without a yield).</li>
</ol>
<div class="sourceCode" id="cb2"><pre
class="sourceCode gdscript"><code class="sourceCode gdscript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="co">_sender</span> <span class="op">=</span> InputSender.<span class="fu">new</span>(Input)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">after_each</span>():</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">release_all</span>()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">clear</span>()</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_shoot</span>():</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> player <span class="op">=</span> Player.<span class="fu">new</span>()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">action_down</span>(<span class="st">&quot;shoot&quot;</span>).<span class="fu">wait_frames</span>(<span class="dv">1</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(<span class="co">_sender</span>, <span class="st">&#39;idle&#39;</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(player.<span class="fu">is_shooting</span>())</span></code></pre></div>
<h2 id="chaining-input-events">Chaining Input Events</h2>
<p>The <code>InputSender</code> methods return the instance so you can
chain multiple calls together to script out a sequence of inputs. The
sequence is immediately started. When the sequence finishes the
<code>'idle'</code> signal is emitted.</p>
<pre><code>var player = Player.new()
var sender = InputSender.new(player)

# press a, then b, then release a, then release b
sender.key_down(&quot;a&quot;).wait(.1)\
    .key_down(KEY_B).wait(.1)\
    .key_up(&quot;a&quot;).wait(.1)\
    .key_up(KEY_B)
yield(sender, &#39;idle&#39;)</code></pre>
<p>The <code>InputSender</code> will emit the <code>idle</code> signal
when all inputs in a sequence have been sent and all <code>waits</code>
have expired.</p>
<p>Any events that do not have a <code>wait</code> or
<code>hold_for</code> call in between them will be fired on the same
frame.</p>
<pre><code># checking for is_action_just_pressed for &quot;jump&quot; and &quot;fire&quot; will be true in the same frame.
sender.action-down(&quot;jump&quot;).action_down(&quot;fire&quot;)</code></pre>
<p>You can use a trailing <code>wait</code> to give the result of the
input time to play out</p>
<pre><code># wait an extra .2 seconds at the end so that asserts will be run after the
# shooting animation finishes.
sender.action_down(&quot;shoot&quot;).hold_for(1).wait(.2)
yield(sender, &#39;idle&#39;)</code></pre>
<h1 id="examples">Examples</h1>
<p>These are examples of scripting out inputs and sending them to
<code>Input</code>. The <code>Player</code> class in these examples
would be handling input in <code>_process</code> or
<code>_process_physics</code>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode gdscript"><code class="sourceCode gdscript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extends</span> GutTest</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># When sending events to Input the InputSender instance should be defined at</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co"># the class level so that you can easily clear it between tests in after_each.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="co">_sender</span> <span class="op">=</span> InputSender.<span class="fu">new</span>(Input)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># IMPORTANT:  When using Input as the receiver of events you should always</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">#             release_all and clear the InputSender so that any</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">#             actions/keys/buttons that are not released in a test are released</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">#             before the next test runs.  &quot;down&quot; events will not be sent by</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">#             Input if the action/button/etc is currently &quot;down&quot;.</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">after_each</span>():</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">release_all</span>()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">clear</span>()</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="co"># In this test we press and hold the jump button for .1 seconds then wait</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># another .3 seconds for the jump to take take place.  We then assert that</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="co"># the character has moved up between 4 and 5 pixels.</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_tapping_jump_jumps_certain_height</span>():</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> player <span class="op">=</span> <span class="fu">add_child_autofree</span>(Player.<span class="fu">new</span>())</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">action_down</span>(<span class="st">&quot;jump&quot;</span>).<span class="fu">hold_for</span>(<span class="fl">.1</span>).<span class="fu">wait</span>(<span class="fl">.3</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(<span class="co">_sender</span>, <span class="st">&#39;idle&#39;</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_between</span>(player.position.y, <span class="dv">4</span>, <span class="dv">5</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="co"># This is similar to the other test but we hold jump for longer and then</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="co"># verify the player jumped higher.</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_holding_jump_jumps_higher</span>():</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> player <span class="op">=</span> <span class="fu">add_child_autofree</span>(Player.<span class="fu">new</span>())</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">action_down</span>(<span class="st">&quot;jump&quot;</span>).<span class="fu">hold_for</span>(<span class="fl">.75</span>)</span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(<span class="co">_sender</span>, <span class="st">&#39;idle&#39;</span>)</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_between</span>(player.position.y, <span class="dv">7</span>, <span class="dv">8</span>)</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="co"># This tests throwing a fireball, like with Ryu or Ken from Street Fighter.</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Note that there is not a hold_for after &quot;forward&quot; and the key_down for</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="co"># fierce punch (FP) immediately after.  This means the &quot;forward&quot; motion AND</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a><span class="co"># FP are pressed in the same frame.</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_fireball_input</span>():</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> player <span class="op">=</span> <span class="fu">add_child_autofree</span>(Player.<span class="fu">new</span>())</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">action_down</span>(<span class="st">&quot;down&quot;</span>).<span class="fu">hold_for</span>(<span class="st">&quot;2f&quot;</span>)\</span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>        .<span class="fu">action_down</span>(<span class="st">&quot;down_forward&quot;</span>).<span class="fu">hold_for</span>(<span class="st">&quot;2f&quot;</span>)\</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        .<span class="fu">action_down</span>(<span class="st">&quot;forward&quot;</span>).<span class="fu">key_down</span>(<span class="st">&quot;FP&quot;</span>)</span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(<span class="co">_sender</span>, <span class="st">&#39;idle&#39;</span>)</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(player.<span class="fu">is_throwing_fireball</span>())</span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a><span class="co"># In this example we are testing that two actions in combination cause the</span></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a><span class="co"># player to slide.  Note that there is no release of the actions in this</span></span>
<span id="cb6-57"><a href="#cb6-57" aria-hidden="true" tabindex="-1"></a><span class="co"># test.  This is a good example of why using release_all in after_each makes</span></span>
<span id="cb6-58"><a href="#cb6-58" aria-hidden="true" tabindex="-1"></a><span class="co"># the tests simplier to write and prevents leaking of inputs from one test to</span></span>
<span id="cb6-59"><a href="#cb6-59" aria-hidden="true" tabindex="-1"></a><span class="co"># another.</span></span>
<span id="cb6-60"><a href="#cb6-60" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_holding_down_and_jump_does_slide</span>():</span>
<span id="cb6-61"><a href="#cb6-61" aria-hidden="true" tabindex="-1"></a>    <span class="kw">var</span> player <span class="op">=</span> <span class="fu">add_child_autofree</span>(Player.<span class="fu">new</span>())</span>
<span id="cb6-62"><a href="#cb6-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-63"><a href="#cb6-63" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">action_down</span>(<span class="st">&quot;down&quot;</span>).<span class="fu">wait</span>(<span class="st">&quot;1f&quot;</span>)\</span>
<span id="cb6-64"><a href="#cb6-64" aria-hidden="true" tabindex="-1"></a>        .<span class="fu">action_down</span>(<span class="st">&quot;jump&quot;</span>).<span class="fu">wait</span>(<span class="st">&quot;2f&quot;</span>)</span>
<span id="cb6-65"><a href="#cb6-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(<span class="co">_sender</span>, <span class="st">&#39;idle&#39;</span>)</span>
<span id="cb6-66"><a href="#cb6-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-67"><a href="#cb6-67" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_gt</span>(player.velocity.x, <span class="dv">0</span>)</span></code></pre></div>
<h1 id="gotchas">Gotchas</h1>
<ul>
<li>When using <code>Input</code> as a receiver, everything in the tree
gets the signals AND any actual inputs from hardware will be sent as
well. It's best not to touch anything when running these tests.</li>
<li>If you use a class level <code>InputSender</code> and forget to call
<code>release_all</code> and <code>clear</code> between tests then
things will eventually start behaving weird and your tests will
pass/fail in unpredictable ways.</li>
</ul>
<h2 id="understanding-inputuse_accumulated_input">Understanding
Input.use_accumulated_input</h2>
<p>When <code>use_accumualted_input</code> is enabled,
<code>Input</code> waits to process input until the end of a frame. This
means that if you do not flush the buffer or there are no "waits" or
calls to <code>yeild</code> before you test how input was processed then
your tests will fail.</p>
<h3 id="testing-with-use_accumulated_input">Testing with
use_accumulated_input</h3>
<h4 id="recommended-approaches">Recommended approaches</h4>
<ol type="1">
<li>If you game does not want to have <code>use_accumulated_input</code>
enabled, then disable it in a an Autoload. GUT loads autoloads before
running so this will disable it for all tests.</li>
<li>Always have a trailing <code>wait</code> when sending input
<code>_sender.key_down('a').wait('10f')</code>. In testing, 6 frames
wasn't enough but 7 was <em>(for reasons I don't understand but probably
should so I made I used 10 frames for good measure)</em>.</li>
<li>After sending all your input, call
<code>Input.flush_buffered_events</code>. Only use this in the specific
cases where you know you want to send inputs immediately since this is
NOT how your game will actually receive inputs.</li>
</ol>
<h4 id="other-ways-that-arent-so-good">Other ways that aren't so
good.</h4>
<p>If you use these approaches you should quarantine these tests in
their own Inner Class or script so that they do not influence other
tests that do not expect the buffer to be constantly flushed or
<code>use_accumulated_input</code> to be disabled.</p>
<ol type="1">
<li>In GUT 7.4.0 <code>InputSender</code> has an
<code>auto_flush_input</code> property which is disabled by default.
When enabled this will call <code>Input.flush_buffered_events</code>
after each input sent through an <code>InputSender</code>. This is a bit
dangerous since this can cause some of your tests to not test the way
your game will recieve input when playing the game.</li>
<li>You can disable <code>use_accumulated_input</code> in
<code>before_all</code> and re-enable in <code>after_all</code>. Just
like with <code>auto_flush_input</code>, this has the potential to not
test all inputs the same way as your game will get them when playing the
game.</li>
</ol>
<h3 id="examples-1">Examples</h3>
<p>The following assume <code>use_accumulated_input</code> is enabled
and uses Godot 3.5 syntax. In 3.4 you have to call
<code>set_use_accumulated_input</code>. There is no way to check the
value of this flag in 3.4.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode gdscript"><code class="sourceCode gdscript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">extends</span> GutTest</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> <span class="co">_sender</span> <span class="op">=</span> InputSender.<span class="fu">new</span>(Input)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">before_all</span>():</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    InputMap.<span class="fu">add_action</span>(<span class="st">&quot;jump&quot;</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">after_each</span>():</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">release_all</span>()</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">clear</span>()</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_when_uai_enabled_input_not_processed_immediately</span>():</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">key_down</span>(<span class="st">&#39;a&#39;</span>)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_false</span>(Input.<span class="fu">is_key_pressed</span>(KEY_A))</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_when_uai_enabled_just_pressed_is_not_processed_immediately</span>():</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">action_down</span>(<span class="st">&#39;jump&#39;</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_false</span>(Input.<span class="fu">is_action_just_pressed</span>(<span class="st">&#39;jump&#39;</span>))</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_when_uai_enabled_waiting_makes_button_pressed</span>():</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># wait 10 frames.  In testing, 6 frames failed, but 7 passed.  Added 3 for</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># good measure.</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">key_down</span>(KEY_Y).<span class="fu">wait</span>(<span class="st">&#39;10f&#39;</span>)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span>(<span class="co">_sender</span>, <span class="st">&#39;idle&#39;</span>)</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(<span class="co">_sender</span>.<span class="fu">is_key_pressed</span>(KEY_Y))</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(Input.<span class="fu">is_key_pressed</span>(KEY_Y))</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_when_uai_enabled_flushig_buffer_sends_input_immediatly</span>():</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">key_down</span>(<span class="st">&#39;a&#39;</span>)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    Input.<span class="fu">flush_buffered_events</span>()</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(Input.<span class="fu">is_key_pressed</span>(KEY_A))</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_disabling_uai_sends_input_immediately</span>():</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    Input.use_accumulated_input <span class="op">=</span> <span class="va">false</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">key_down</span>(<span class="st">&#39;a&#39;</span>)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(Input.<span class="fu">is_key_pressed</span>(KEY_A))</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># re-enable so we don&#39;t ruin other tests</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    Input.use_accumulated_input <span class="op">=</span> <span class="va">true</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="kw">func</span> <span class="fu">test_when_uai_enabled_flushing_buffer_just_pressed_is_processed_immediately</span>():</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">_sender</span>.<span class="fu">action_down</span>(<span class="st">&#39;jump&#39;</span>)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    Input.<span class="fu">flush_buffered_events</span>()</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    <span class="fu">assert_true</span>(Input.<span class="fu">is_action_just_pressed</span>(<span class="st">&#39;jump&#39;</span>))</span></code></pre></div>
<h1 id="functions">Functions</h1>
<p><strong><a name="new">new(receiver=null)</a></strong><br/> The
optional receiver will be added to the list of recievers.</p>
<p><strong><a name="add_receiver">add_receiver(obj)</a></strong><br/>
Add an object to receive input events.</p>
<p><strong><a name="get_receivers">get_receivers()</a></strong><br/>
Returns the receivers that have been added.</p>
<p><strong><a name="release_all">release_all()</a></strong><br/>
Releases all <code>InputEventKey</code>, <code>InputEventAction</code>,
and <code>InputEventMouseButton</code> events that have passed through
the <code>InputSender</code>. These events could have been generated via
the various <code>_down</code> methods or passed to
<code>send_event</code>.</p>
<p>This will send the "release" event (<code>pressed = false</code>) to
all receivers. This should be done between each test when using
<code>Input</code> as a receiver.</p>
<p><strong><a name="clear">clear()</a></strong><br/> Clears the input
queue and any state such as the last event sent and any pressed
actions/buttons. Does not clear the list of receivers.</p>
<p>This should be done between each test when the
<code>InputSender</code> is a class level variable so that state does
not leak between tests.</p>
<p><strong><a name="is_idle">is_idle()</a></strong><br/> Returns true if
the input queue has items to be processed, false if not.</p>
<p><strong><a name="wait">wait(t)</a></strong><br/> Adds a delay between
the last input queue item added and any queue item added next. By
default this will wait <code>t</code> seconds. You can specify a number
of frames to wait by passing a string composed of a number and "f". For
example <code>wait("5f")</code> will wait 5 frames.</p>
<p><strong><a name="wait_frames">wait_frames(num_frames)</a></strong><br/>
Same as <code>wait</code> but only accepts a number of frames to
wait.</p>
<p><strong><a name="wait_secs">wait_secs(num_secs)</a></strong><br/>
Same as <code>wait</code> but only accepts a number of seconds to
wait.</p>
<p><strong><a name="hold_for">hold_for(duration)</a></strong><br/> This
is a special <code>wait</code> that will emit the previous input queue
item with <code>pressed = false</code> after a delay. If you pass a
number then it will wait that many seconds. You can also use the
<code>"4f"</code> format to wait a specific number of frames.</p>
<p>For example <code>sender.action_down('jump').hold_for("10f")</code>
will cause two <code>InputEventAction</code> instances to be sent. The
"jump-down" event from <code>action_down</code> and then a "jump-up"
event after 10 frames.</p>
<p><strong><a name="mouse_set_position">mouse_set_position(position,
global_position=null)</a></strong><br/> Sets the mouse's position. This
does not send an event. This position will be used for the next call to
<code>mouse_relative_motion</code>.</p>
<p><strong><a name="set_auto_flush_input">set_auto_flush_input(val)</a></strong><br/>
Enable/Disable auto flusing of input. When enabled the
<code>InputSender</code> will call
<code>Input.flush_buffered_events</code> after each event is sent. See
the <code>use_accumulated_input</code> section for more information.</p>
<p><strong><a name="get_auto_flush_input">get_auto_flush_input()</a></strong><br/>
Get it.</p>
<h1 id="sending-inputevents-1">Sending InputEvents</h1>
<p><strong><a name="send_event">send_event(event)</a></strong><br/>
Create your own event and use this to send it to all receivers.</p>
<p><strong><a name="key_down">key_down(which)</a></strong><br/> Sends a
<code>InputEventKey</code> event with <code>pressed</code> =
<code>true</code>. <code>which</code> can be a character or a
<code>KEY_*</code> constant.</p>
<p><strong><a name="key_up">key_up(which)</a></strong><br/> Sends a
<code>InputEventKey</code> event with <code>pressed</code> =
<code>false</code>. <code>which</code> can be a character or a
<code>KEY_*</code> constant.</p>
<p><strong><a name="key_echo">key_echo()</a></strong><br/> Sends an echo
<code>InputEventKey</code> event of the last key event.</p>
<p><strong><a name="action_down">action_down(which,
strength=1.0)</a></strong><br/> Sends a "action down"
<code>InputEventAction</code> instance. <code>which</code> is the name
of the action defined in the Key Map.</p>
<p><strong><a name="action_up">action_up(which,
strength=1.0)</a></strong><br/> Sends a "action up"
<code>InputEventAction</code> instance. <code>which</code> is the name
of the action defined in the Key Map.</p>
<p><strong><a name="mouse_left_button_down">mouse_left_button_down(position,
global_position=null)</a></strong><br/> Sends a "button down"
<code>InputEventMouseButton</code> for the left mouse button.</p>
<p><strong><a name="mouse_left_button_up">mouse_left_button_up(position,
global_position=null)</a></strong><br/> Sends a "button up"
<code>InputEventMouseButton</code> for the left mouse button.</p>
<p><strong><a name="mouse_double_click">mouse_double_click(position,
global_position=null)</a></strong><br/> Sends a "double click"
<code>InputEventMouseButton</code> for the left mouse button.</p>
<p><strong><a name="mouse_right_button_down">mouse_right_button_down(position,
global_position=null)</a></strong><br/> Sends a "button down"
<code>InputEventMouseButton</code> for the right mouse button.</p>
<p><strong><a name="mouse_right_button_up">mouse_right_button_up(position,
global_position=null)</a></strong><br/> Sends a "button up"
<code>InputEventMouseButton</code> for the right mouse button.</p>
<p><strong><a name="mouse_motion(">mouse_motion(position,
global_position=null)</a></strong><br/> Sends a "InputEventMouseMotion"
to move the mouse the specified postions.</p>
<p><strong><a name="mouse_relative_motion">mouse_relative_motion(offset,
speed=Vector2(0, 0))</a></strong><br/> Sends a "InputEventMouseMotion"
that moves the mouse <code>offset</code> from the last
<code>mouse_motion</code> or <code>mouse_set_position</code> call.</p>
</body>
</html>

            </embed>
        </div>
    </div>

</body>

</html>